{
  "version": 3,
  "sources": ["../src/index.ts", "../src/components/AddressAutofill.tsx", "../src/components/SearchBox.tsx", "../src/components/Geocoder.tsx", "../src/components/AddressMinimap.tsx", "../src/hooks/useEvented.tsx", "../src/hooks/useAddressAutofillCore.tsx", "../src/hooks/useSearchBoxCore.tsx", "../src/hooks/useGeocodingCore.tsx", "../src/hooks/useSearchSession.tsx", "../src/hooks/useConfirmAddress.tsx"],
  "sourcesContent": ["import '@mapbox/search-js-web';\nexport { config } from '@mapbox/search-js-web';\n\nexport { AddressAutofill } from './components/AddressAutofill';\nexport { SearchBox } from './components/SearchBox';\nexport { Geocoder } from './components/Geocoder';\nexport { AddressMinimap } from './components/AddressMinimap';\n\nexport { useEvented } from './hooks/useEvented';\nexport {\n  useAddressAutofillCore,\n  useAddressAutofillCore as useMapboxAutofill // alias for backward compatibility\n} from './hooks/useAddressAutofillCore';\nexport { useSearchBoxCore } from './hooks/useSearchBoxCore';\nexport { useGeocodingCore } from './hooks/useGeocodingCore';\nexport { useSearchSession } from './hooks/useSearchSession';\nexport { useConfirmAddress } from './hooks/useConfirmAddress';\n", "/* eslint-disable @typescript-eslint/no-namespace */\n\nimport React, { useRef, useEffect, useImperativeHandle } from 'react';\n\nimport {\n  AddressAutofillOptions,\n  AddressAutofillSuggestionResponse,\n  AddressAutofillRetrieveResponse\n} from '@mapbox/search-js-core';\nimport {\n  MapboxAddressAutofill,\n  Theme,\n  MapboxHTMLEvent,\n  AddressConfirmOptions,\n  PopoverOptions\n} from '@mapbox/search-js-web';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      'mapbox-address-autofill': any;\n    }\n  }\n}\n\n/**\n * @typedef AddressAutofillRefType\n */\nexport interface AddressAutofillRefType {\n  /**\n   * @see {@link MapboxAddressAutofill#focus}\n   */\n  focus: typeof MapboxAddressAutofill.prototype.focus;\n}\n\n/**\n * @typedef AddressAutofillProps\n */\nexport interface AddressAutofillProps {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n  /**\n   * Options to pass to the underlying {@link AddressAutofillCore} interface.\n   * @example\n   * ```typescript\n   * <AddressAutofill options={{\n   *  language: 'en',\n   *  country: 'US',\n   * }}>\n   * ```\n   */\n  options?: Partial<AddressAutofillOptions>;\n  /**\n   * The {@link Theme} to use for styling the autofill and confirmation dialog\n   * components.\n   * @example\n   * ```typescript\n   * <AddressAutofill theme={{\n   *   variables: {\n   *     colorPrimary: 'myBrandRed'\n   *   }\n   * }}>\n   * ```\n   */\n  theme?: Theme;\n  /**\n   * The {@link PopoverOptions} to define popover positioning.\n   * @example\n   * ```typescript\n   * <AddressAutofill popoverOptions={{\n   *   placement: 'top-start',\n   *   flip: true,\n   *   offset: 5\n   * }}>\n   * ```\n   */\n  popoverOptions?: Partial<PopoverOptions>;\n  /**\n   * If true, forms autofilled by the browser will prompt the\n   * {@link confirmAddress} dialog for user confirmation.\n   * An {@link AddressConfirmOptions} object can also be passed\n   * to prompt {@link confirmAddress} with custom options.\n   * Defaults to false.\n   * @example\n   * ```typescript\n   * <AddressAutofill confirmOnBrowserAutofill={{\n   *   minimap: true,\n   *   skipConfirmModal: (feature) =>\n   *     ['exact', 'high'].includes(\n   *       feature.properties.match_code.confidence\n   *     )\n   * }}>\n   * ```\n   */\n  confirmOnBrowserAutofill?: boolean | AddressConfirmOptions;\n\n  /**\n   * Enables the browser's autocomplete popup to show during the first two typed characters while Mapbox results are suppressed. Defaults to false.\n   *\n   * **Note:** Due to varying specifications, efforts to suppress browser autocomplete behavior may not work on all browsers.\n   */\n  browserAutofillEnabled?: boolean;\n\n  /**\n   * Children to render inside the autofill component. This **must** include\n   * an [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text) element\n   * with either autocomplete type `\"street-address\"` or `\"address-line1\"`.\n   */\n  children: React.ReactChild;\n  /**\n   * Callback for when the `<input>` value changes.\n   */\n  onChange?: (value: string) => void;\n  /**\n   * Fired when the user is typing in the input and provides a list of suggestions.\n   * The underlying response from {@link AddressAutofillCore} is passed.\n   */\n  onSuggest?: (res: AddressAutofillSuggestionResponse) => void;\n  /**\n   * Fired when {@link AddressAutofillCore} has errored providing a list of suggestions.\n   * The underlying error is passed.\n   */\n  onSuggestError?: (error: Error) => void;\n  /**\n   * Fired when the user has selected a suggestion, before the form is autofilled.\n   * The underlying response from {@link AddressAutofillCore} is passed.\n   */\n  onRetrieve?: (res: AddressAutofillRetrieveResponse) => void;\n\n  /**\n   * A callback providing the opportunity to validate and/or manipulate the input text before it triggers a search, for example by using a regular expression.\n   * If a truthy string value is returned, it will be passed into the underlying search API. If `null`, `undefined` or empty string is returned, no search request will be performed.\n   */\n  interceptSearch?: (value: string) => string;\n}\n\n/**\n * `<AddressAutofill>` is a React component that wraps an address\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text) element with intelligent, location-aware autocomplete functionality.\n *\n * To use this element, you must have a [Mapbox access token](https://www.mapbox.com/help/create-api-access-token/).\n *\n * This component must be a descendant of a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form), and the form\n * must have inputs with proper HTML `autocomplete` attributes. If your application works with browser autofill, you may already have\n * this functionality.\n * - [The HTML autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)\n * - [Autofill](https://web.dev/learn/forms/autofill/)\n *\n * Internally, this wraps the [`<mapbox-address-autofill>`](https://docs.mapbox.com/mapbox-search-js/api/web/autofill/#mapboxaddressautofill) element.\n *\n * @function AddressAutofill\n * @param {AddressAutofillProps} props\n * @example\n * ```typescript\n * import { AddressAutofill } from '@mapbox/search-js-react'\n * export function Component() {\n *   const [value, setValue] = React.useState('');\n *\n *   const handleChange = (e) => {\n *     setValue(e.target.value);\n *   };\n *\n *   return (\n *     <form>\n *       <AddressAutofill accessToken={'YOUR_MAPBOX_ACCESS_TOKEN'}>\n *         <input\n *           autoComplete=\"shipping address-line1\"\n *           value={value}\n *           onChange={handleChange}\n *         />\n *       </AddressAutofill>\n *     </form>\n *   );\n * }\n * ```\n */\nexport const AddressAutofill = React.forwardRef(\n  (props: AddressAutofillProps, refProp): React.ReactElement => {\n    const {\n      accessToken,\n      options,\n      theme,\n      popoverOptions,\n      confirmOnBrowserAutofill,\n      browserAutofillEnabled,\n      children,\n      onChange,\n      onSuggest,\n      onSuggestError,\n      onRetrieve,\n      interceptSearch\n    } = props;\n    const ref = useRef<MapboxAddressAutofill>();\n\n    useImperativeHandle(refProp, () => ({\n      focus: () => {\n        if (ref.current) return ref.current.focus();\n        throw new Error('AddressAutofill is not mounted');\n      }\n    }));\n\n    // Update options.\n    useEffect(() => {\n      if (ref.current) ref.current.options = options;\n    }, [ref.current, options]);\n\n    // Update intercept search.\n    useEffect(() => {\n      if (ref.current) ref.current.interceptSearch = interceptSearch;\n    }, [ref.current, options]);\n\n    // Update theme.\n    useEffect(() => {\n      if (ref.current) ref.current.theme = theme;\n    }, [ref.current, theme]);\n\n    // Update popoverOptions\n    useEffect(() => {\n      if (ref.current) ref.current.popoverOptions = popoverOptions;\n    }, [ref.current, popoverOptions]);\n\n    // Update confirmOnBrowserAutofill\n    useEffect(() => {\n      if (ref.current)\n        ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;\n    }, [ref.current, confirmOnBrowserAutofill]);\n\n    // Update browserAutofillEnabled\n    useEffect(() => {\n      if (ref.current)\n        ref.current.browserAutofillEnabled = browserAutofillEnabled;\n    }, [ref.current, browserAutofillEnabled]);\n\n    // Update onSuggest.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggest) return;\n\n      const fn = (e: MapboxHTMLEvent<AddressAutofillSuggestionResponse>) =>\n        onSuggest(e.detail);\n\n      node.addEventListener('suggest', fn);\n      return () => {\n        node.removeEventListener('suggest', fn);\n      };\n    }, [ref.current, onSuggest]);\n\n    // Update onSuggestError.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggestError) return;\n\n      const fn = (e: MapboxHTMLEvent<Error>) => onSuggestError(e.detail);\n\n      node.addEventListener('suggesterror', fn);\n      return () => {\n        node.removeEventListener('suggesterror', fn);\n      };\n    }, [ref.current, onSuggestError]);\n\n    // Update onRetrieve.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onRetrieve) return;\n\n      const fn = (e: MapboxHTMLEvent<AddressAutofillRetrieveResponse>) =>\n        onRetrieve(e.detail);\n\n      node.addEventListener('retrieve', fn);\n      return () => {\n        node.removeEventListener('retrieve', fn);\n      };\n    }, [ref.current, onRetrieve]);\n\n    // Update onChange.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onChange) return;\n\n      const fn = (e: MapboxHTMLEvent<string>) => {\n        if (e.target !== e.currentTarget) return; // ignore child input event\n        onChange(e.detail);\n      };\n\n      node.addEventListener('input', fn);\n      return () => {\n        node.removeEventListener('input', fn);\n      };\n    }, [ref.current, onChange]);\n\n    // Update accessToken.\n    useEffect(() => {\n      if (ref.current) ref.current.accessToken = accessToken;\n    }, [ref.current, accessToken]);\n\n    return (\n      <mapbox-address-autofill ref={ref}>{children}</mapbox-address-autofill>\n    );\n  }\n);\n", "/* eslint-disable @typescript-eslint/no-namespace */\n\nimport React, { useRef, useEffect, useImperativeHandle } from 'react';\nimport mapboxgl from 'mapbox-gl';\n\nimport {\n  SearchBoxOptions,\n  SearchBoxSuggestionResponse,\n  SearchBoxRetrieveResponse\n} from '@mapbox/search-js-core';\nimport {\n  MapboxSearchBox,\n  Theme,\n  MapboxHTMLEvent,\n  PopoverOptions\n} from '@mapbox/search-js-web';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      'mapbox-search-box': any;\n    }\n  }\n}\n\n/**\n * @typedef SearchBoxRefType\n */\nexport interface SearchBoxRefType {\n  /**\n   * @see {@link MapboxSearchBox#focus}\n   */\n  focus: typeof MapboxSearchBox.prototype.focus;\n  /**\n   * @see {@link MapboxSearchBox#search}\n   */\n  search: typeof MapboxSearchBox.prototype.search;\n}\n\n/**\n * @typedef SearchBoxProps\n */\nexport interface SearchBoxProps {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n  /**\n   * Options to pass to the underlying {@link SearchBoxCore} interface.\n   * @example\n   * ```typescript\n   * <SearchBox options={{\n   *  language: 'en',\n   *  country: 'US',\n   * }}>\n   * ```\n   */\n  options?: Partial<SearchBoxOptions>;\n  /**\n   * The {@link Theme} to use for styling the search box.\n   * @example\n   * ```typescript\n   * <SearchBox theme={{\n   *   variables: {\n   *     colorPrimary: 'myBrandRed'\n   *   }\n   * }}>\n   * ```\n   */\n  theme?: Theme;\n  /**\n   * The {@link PopoverOptions} to define popover positioning.\n   * @example\n   * ```typescript\n   * <SearchBox popoverOptions={{\n   *   placement: 'top-start',\n   *   flip: true,\n   *   offset: 5\n   * }}>\n   * ```\n   */\n  popoverOptions?: Partial<PopoverOptions>;\n  /**\n   * The input element's placeholder text. The default value may be localized if {@link SearchBoxOptions#language} is set.\n   */\n  placeholder?: string;\n  /**\n   * If specified, the map will be centered on the retrieved suggestion.\n   */\n  map?: mapboxgl.Map;\n  /**\n   * If `true`, a [Marker](https://docs.mapbox.com/mapbox-gl-js/api/#marker) will be added to the map at the location of the user-selected result using a default set of Marker options.  If the value is an object, the marker will be constructed using these options. If `false`, no marker will be added to the map. Requires that {@link SearchBoxProps#mapboxgl} also be set.\n   */\n  marker?: boolean | mapboxgl.MarkerOptions;\n  /**\n   * A [mapbox-gl](https://github.com/mapbox/mapbox-gl-js) instance to use when creating [Markers](https://docs.mapbox.com/mapbox-gl-js/api/#marker). Required if {@link SearchBoxProps#marker} is `true`.\n   */\n  mapboxgl?: typeof mapboxgl;\n  /**\n   * Value to display in the search box.\n   */\n  value?: string;\n  /**\n   * Callback for when the value changes.\n   */\n  onChange?: (value: string) => void;\n  /**\n   * Fired when the user is typing in the input and provides a list of suggestions.\n   * The underlying response from {@link SearchBoxCore} is passed.\n   */\n  onSuggest?: (res: SearchBoxSuggestionResponse) => void;\n  /**\n   * Fired when {@link SearchBoxCore} has errored providing a list of suggestions.\n   * The underlying error is passed.\n   */\n  onSuggestError?: (error: Error) => void;\n  /**\n   * Fired when the user has selected a suggestion.\n   * The underlying response from {@link SearchBoxCore} is passed.\n   */\n  onRetrieve?: (res: SearchBoxRetrieveResponse) => void;\n  /**\n   * Fired when the user has cleared the search box.\n   */\n  onClear?: () => void;\n\n  /**\n   * A callback providing the opportunity to validate and/or manipulate the input text before it triggers a search, for example by using a regular expression.\n   * If a truthy string value is returned, it will be passed into the underlying search API. If `null`, `undefined` or empty string  is returned, no search request will be performed.\n   */\n  interceptSearch?: (value: string) => string;\n}\n\n/**\n * `<SearchBox>` is a React component that provides an interactive search box,\n * powered by the Mapbox Search Box API.\n *\n * To use this element, you must have a [Mapbox access token](https://www.mapbox.com/help/create-api-access-token/).\n *\n * Internally, this wraps the [`<mapbox-search-box>`](https://docs.mapbox.com/mapbox-search-js/api/web/search/#mapboxsearchbox) element.\n *\n * @function SearchBox\n * @param {SearchBoxProps} props\n * @example\n * ```typescript\n * import { SearchBox } from \"@mapbox/search-js-react\";\n * export function Component() {\n *   const [value, setValue] = React.useState('');\n *\n *   const handleChange = (d) => {\n *     setValue(d);\n *   };\n *   return (\n *     <SearchBox\n *       options={{\n *         proximity: {\n *           lng: -122.431297,\n *           lat: 37.773972,\n *         },\n *       }}\n *       value={value}\n *       onChange={handleChange}\n *       accessToken=\"YOUR_MAPBOX_ACCESS_TOKEN\"\n *     />\n *   );\n * }\n * ```\n */\nexport const SearchBox = React.forwardRef(\n  (props: SearchBoxProps, refProp): React.ReactElement => {\n    const {\n      accessToken,\n      options,\n      theme,\n      popoverOptions,\n      placeholder,\n      map,\n      marker,\n      mapboxgl,\n      value,\n      onChange,\n      onSuggest,\n      onSuggestError,\n      onRetrieve,\n      onClear,\n      interceptSearch\n    } = props;\n    const ref = useRef<MapboxSearchBox>();\n\n    useImperativeHandle(refProp, () => ({\n      focus: () => {\n        if (ref.current) return ref.current.focus();\n        throw new Error('SearchBox is not mounted');\n      },\n      search: (text: string) => {\n        if (ref.current) return ref.current.search(text);\n        throw new Error('SearchBox is not mounted');\n      }\n    }));\n\n    // Update options.\n    useEffect(() => {\n      if (ref.current) ref.current.options = options || {};\n    }, [ref.current, options]);\n\n    // Update intercept search.\n    useEffect(() => {\n      if (ref.current) ref.current.interceptSearch = interceptSearch;\n    }, [ref.current, interceptSearch]);\n\n    // Update theme.\n    useEffect(() => {\n      if (ref.current) ref.current.theme = theme;\n    }, [ref.current, theme]);\n\n    // Update popoverOptions\n    useEffect(() => {\n      if (ref.current) ref.current.popoverOptions = popoverOptions;\n    }, [ref.current, popoverOptions]);\n\n    // Update placeholder\n    useEffect(() => {\n      if (ref.current) ref.current.placeholder = placeholder;\n    }, [ref.current, placeholder]);\n\n    // Update value.\n    useEffect(() => {\n      if (ref.current) ref.current.value = value || '';\n    }, [ref.current, value]);\n\n    // Update map.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      node.bindMap(map);\n      return () => {\n        node.unbindMap();\n      };\n    }, [ref.current, map]);\n\n    // Update marker.\n    useEffect(() => {\n      if (ref.current) ref.current.marker = marker;\n    }, [ref.current, marker]);\n\n    // Update mapboxgl.\n    useEffect(() => {\n      if (ref.current) ref.current.mapboxgl = mapboxgl;\n    }, [ref.current, mapboxgl]);\n\n    // Update onSuggest.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggest) return;\n\n      const fn = (e: MapboxHTMLEvent<SearchBoxSuggestionResponse>) =>\n        onSuggest(e.detail);\n\n      node.addEventListener('suggest', fn);\n      return () => {\n        node.removeEventListener('suggest', fn);\n      };\n    }, [ref.current, onSuggest]);\n\n    // Update onSuggestError.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggestError) return;\n\n      const fn = (e: MapboxHTMLEvent<Error>) => onSuggestError(e.detail);\n\n      node.addEventListener('suggesterror', fn);\n      return () => {\n        node.removeEventListener('suggesterror', fn);\n      };\n    }, [ref.current, onSuggestError]);\n\n    // Update onRetrieve.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onRetrieve) return;\n\n      const fn = (e: MapboxHTMLEvent<SearchBoxRetrieveResponse>) =>\n        onRetrieve(e.detail);\n\n      node.addEventListener('retrieve', fn);\n      return () => {\n        node.removeEventListener('retrieve', fn);\n      };\n    }, [ref.current, onRetrieve]);\n\n    // Update onChange.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onChange) return;\n\n      const fn = (e: MapboxHTMLEvent<string>) => {\n        if (e.target !== e.currentTarget) return; // ignore child input event\n        onChange(e.detail);\n      };\n\n      node.addEventListener('input', fn);\n      return () => {\n        node.removeEventListener('input', fn);\n      };\n    }, [ref.current, onChange]);\n\n    // Update onClear.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onClear) return;\n\n      const fn = () => {\n        onClear();\n      };\n\n      node.addEventListener('clear', fn);\n      return () => {\n        node.removeEventListener('clear', fn);\n      };\n    }, [ref.current, onClear]);\n\n    // Update accessToken.\n    useEffect(() => {\n      if (ref.current) ref.current.accessToken = accessToken;\n    }, [ref.current, accessToken]);\n\n    return <mapbox-search-box ref={ref} />;\n  }\n);\n", "/* eslint-disable @typescript-eslint/no-namespace */\n\nimport React, { useRef, useEffect, useImperativeHandle } from 'react';\nimport mapboxgl from 'mapbox-gl';\n\nimport {\n  GeocodingOptions,\n  GeocodingResponse,\n  GeocodingFeature\n} from '@mapbox/search-js-core';\nimport {\n  MapboxGeocoder,\n  Theme,\n  MapboxHTMLEvent,\n  PopoverOptions\n} from '@mapbox/search-js-web';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      'mapbox-geocoder': any;\n    }\n  }\n}\n\n/**\n * @typedef GeocoderRefType\n */\nexport interface GeocoderRefType {\n  /**\n   * @see {@link MapboxGeocoder#focus}\n   */\n  focus: typeof MapboxGeocoder.prototype.focus;\n  /**\n   * @see {@link MapboxGeocoder#search}\n   */\n  search: typeof MapboxGeocoder.prototype.search;\n}\n\n/**\n * @typedef GeocoderProps\n */\nexport interface GeocoderProps {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n  /**\n   * Options to pass to the underlying {@link GeocodingCore} interface.\n   * @example\n   * ```typescript\n   * <Geocoder options={{\n   *  language: 'en',\n   *  country: 'US',\n   * }}>\n   * ```\n   */\n  options?: Partial<GeocodingOptions>;\n  /**\n   * The {@link Theme} to use for styling the geocoder.\n   * @example\n   * ```typescript\n   * <Geocoder theme={{\n   *   variables: {\n   *     colorPrimary: 'myBrandRed'\n   *   }\n   * }}>\n   * ```\n   */\n  theme?: Theme;\n  /**\n   * The {@link PopoverOptions} to define popover positioning.\n   * @example\n   * ```typescript\n   * <Geocoder popoverOptions={{\n   *   placement: 'top-start',\n   *   flip: true,\n   *   offset: 5\n   * }}>\n   * ```\n   */\n  popoverOptions?: Partial<PopoverOptions>;\n  /**\n   * The input element's placeholder text. The default value may be localized if {@link GeocodingOptions#language} is set.\n   */\n  placeholder?: string;\n  /**\n   * If specified, the map will be centered on the retrieved suggestion.\n   */\n  map?: mapboxgl.Map;\n  /**\n   * If `true`, a [Marker](https://docs.mapbox.com/mapbox-gl-js/api/#marker) will be added to the map at the location of the user-selected result using a default set of Marker options.  If the value is an object, the marker will be constructed using these options. If `false`, no marker will be added to the map. Requires that {@link GeocoderProps#mapboxgl} also be set.\n   */\n  marker?: boolean | mapboxgl.MarkerOptions;\n  /**\n   * A [mapbox-gl](https://github.com/mapbox/mapbox-gl-js) instance to use when creating [Markers](https://docs.mapbox.com/mapbox-gl-js/api/#marker). Required if {@link GeocoderProps#marker} is `true`.\n   */\n  mapboxgl?: typeof mapboxgl;\n  /**\n   * Value to display in the geocoder.\n   */\n  value?: string;\n  /**\n   * Callback for when the value changes.\n   */\n  onChange?: (value: string) => void;\n  /**\n   * Fired when the user is typing in the input and provides a list of suggestions.\n   * The underlying response from {@link GeocodingCore} is passed.\n   */\n  onSuggest?: (res: GeocodingResponse) => void;\n  /**\n   * Fired when {@link GeocodingCore} has errored providing a list of suggestions.\n   * The underlying error is passed.\n   */\n  onSuggestError?: (error: Error) => void;\n  /**\n   * Fired when the user has selected a suggestion.\n   * The underlying feature from {@link GeocodingCore} is passed.\n   */\n  onRetrieve?: (res: GeocodingFeature) => void;\n  /**\n   * Fired when the user has cleared the search box.\n   */\n  onClear?: () => void;\n\n  /**\n   * A callback providing the opportunity to validate and/or manipulate the input text before it triggers a search, for example by using a regular expression.\n   * If a truthy string value is returned, it will be passed into the underlying search API. If `null`, `undefined` or empty string  is returned, no search request will be performed.\n   */\n  interceptSearch?: (value: string) => string;\n}\n\n/**\n * `<Geocoder>` is a React component that provides an interactive geocoder,\n * powered by the Mapbox Geocoding API.\n *\n * To use this element, you must have a [Mapbox access token](https://www.mapbox.com/help/create-api-access-token/).\n *\n * Internally, this wraps the [`<mapbox-geocoder>`](https://docs.mapbox.com/mapbox-search-js/api/web/search/#mapboxgeocoder) element.\n *\n * @function Geocoder\n * @param {GeocoderProps} props\n * @example\n * ```typescript\n * import { Geocoder } from \"@mapbox/search-js-react\";\n * export function Component() {\n *   const [value, setValue] = React.useState('');\n *\n *   const handleChange = (d) => {\n *     setValue(d);\n *   };\n *   return (\n *     <Geocoder\n *       options={{\n *         proximity: {\n *           lng: -122.431297,\n *           lat: 37.773972,\n *         },\n *       }}\n *       value={value}\n *       onChange={handleChange}\n *       accessToken=\"YOUR_MAPBOX_ACCESS_TOKEN\"\n *     />\n *   );\n * }\n * ```\n */\nexport const Geocoder = React.forwardRef(\n  (props: GeocoderProps, refProp): React.ReactElement => {\n    const {\n      accessToken,\n      options,\n      theme,\n      popoverOptions,\n      placeholder,\n      map,\n      marker,\n      mapboxgl,\n      value,\n      onChange,\n      onSuggest,\n      onSuggestError,\n      onRetrieve,\n      onClear,\n      interceptSearch\n    } = props;\n    const ref = useRef<MapboxGeocoder>();\n\n    useImperativeHandle(refProp, () => ({\n      focus: () => {\n        if (ref.current) return ref.current.focus();\n        throw new Error('Geocoder is not mounted');\n      },\n      search: (text: string) => {\n        if (ref.current) return ref.current.search(text);\n        throw new Error('Geocoder is not mounted');\n      }\n    }));\n\n    // Update options.\n    useEffect(() => {\n      if (ref.current) ref.current.options = options || {};\n    }, [ref.current, options]);\n\n    // Update intercept search.\n    useEffect(() => {\n      if (ref.current) ref.current.interceptSearch = interceptSearch;\n    }, [ref.current, interceptSearch]);\n\n    // Update theme.\n    useEffect(() => {\n      if (ref.current) ref.current.theme = theme;\n    }, [ref.current, theme]);\n\n    // Update popoverOptions\n    useEffect(() => {\n      if (ref.current) ref.current.popoverOptions = popoverOptions;\n    }, [ref.current, popoverOptions]);\n\n    // Update placeholder\n    useEffect(() => {\n      if (ref.current) ref.current.placeholder = placeholder;\n    }, [ref.current, placeholder]);\n\n    // Update value.\n    useEffect(() => {\n      if (ref.current) ref.current.value = value || '';\n    }, [ref.current, value]);\n\n    // Update map.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      node.bindMap(map);\n      return () => {\n        node.unbindMap();\n      };\n    }, [ref.current, map]);\n\n    // Update marker.\n    useEffect(() => {\n      if (ref.current) ref.current.marker = marker;\n    }, [ref.current, marker]);\n\n    // Update mapboxgl.\n    useEffect(() => {\n      if (ref.current) ref.current.mapboxgl = mapboxgl;\n    }, [ref.current, mapboxgl]);\n\n    // Update onSuggest.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggest) return;\n\n      const fn = (e: MapboxHTMLEvent<GeocodingResponse>) => onSuggest(e.detail);\n\n      node.addEventListener('suggest', fn);\n      return () => {\n        node.removeEventListener('suggest', fn);\n      };\n    }, [ref.current, onSuggest]);\n\n    // Update onSuggestError.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onSuggestError) return;\n\n      const fn = (e: MapboxHTMLEvent<Error>) => onSuggestError(e.detail);\n\n      node.addEventListener('suggesterror', fn);\n      return () => {\n        node.removeEventListener('suggesterror', fn);\n      };\n    }, [ref.current, onSuggestError]);\n\n    // Update onRetrieve.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onRetrieve) return;\n\n      const fn = (e: MapboxHTMLEvent<GeocodingFeature>) => onRetrieve(e.detail);\n\n      node.addEventListener('retrieve', fn);\n      return () => {\n        node.removeEventListener('retrieve', fn);\n      };\n    }, [ref.current, onRetrieve]);\n\n    // Update onChange.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onChange) return;\n\n      const fn = (e: MapboxHTMLEvent<string>) => {\n        if (e.target !== e.currentTarget) return; // ignore child input event\n        onChange(e.detail);\n      };\n\n      node.addEventListener('input', fn);\n      return () => {\n        node.removeEventListener('input', fn);\n      };\n    }, [ref.current, onChange]);\n\n    // Update onClear.\n    useEffect(() => {\n      const node = ref.current;\n      if (!node) return;\n\n      if (!onClear) return;\n\n      const fn = () => {\n        onClear();\n      };\n\n      node.addEventListener('clear', fn);\n      return () => {\n        node.removeEventListener('clear', fn);\n      };\n    }, [ref.current, onClear]);\n\n    // Update accessToken.\n    useEffect(() => {\n      if (ref.current) ref.current.accessToken = accessToken;\n    }, [ref.current, accessToken]);\n\n    return <mapbox-geocoder ref={ref} />;\n  }\n);\n", "/* eslint-disable @typescript-eslint/no-namespace */\n\nimport React, { useRef, useEffect } from 'react';\n\nimport {\n  Anchor,\n  MapboxAddressMinimap,\n  MapStyleMode,\n  Theme\n} from '@mapbox/search-js-web';\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      'mapbox-address-minimap': any;\n    }\n  }\n}\n\n/**\n * @typedef AddressMinimapProps\n */\nexport interface AddressMinimapProps {\n  /**\n   * If `true`, the marker can be moved around the map. Defaults to `false`.\n   *\n   * When editable, the marker can be moved around the map and the updated\n   * location can be referenced from the {@link AddressMinimapProps#onSaveMarkerLocation} callback.\n   */\n  canAdjustMarker?: boolean;\n  /**\n   * If `true`, the map when panned moves around the marker, keeping the marker\n   * centered. Defaults to `false`.\n   */\n  keepMarkerCentered?: boolean;\n  /**\n   * The anchor of the marker, relative to center of the expanded size. Defaults to `'bottom'`.\n   */\n  markerAnchor?: Anchor;\n  /**\n   * A client-defined callback that is triggered when the \"Save\" button is clicked in the editing interface,\n   * and gives access to the adjusted marker coordinate.\n   */\n  onSaveMarkerLocation?: (coordinate: [number, number]) => void;\n\n  /**\n   * Must be `true` for the minimap to be shown, in addition to {@link AddressMinimapProps#feature}\n   * being present.\n   */\n  show?: boolean;\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   *\n   * If not explicitly set on the component, this will reference the value in the global config object.\n   */\n  accessToken?: string;\n  /**\n   * A [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) Feature representing\n   * a [Point](https://geojson.org/geojson-spec.html#point) geometry.\n   *\n   * The minimap is hidden unless {@link AddressMinimapProps#feature} is truthy.\n   */\n  feature?: GeoJSON.Feature<GeoJSON.Point>;\n\n  /**\n   * If `true`, the map will have an image toggle between Map and Satellite styles.\n   */\n  satelliteToggle?: boolean;\n  /**\n   * The {@link Theme} to use for styling interface buttons.\n   * @example\n   * ```typescript\n   * <AddressMinimap theme={{\n   *   variables: {\n   *     colorPrimary: 'myBrandRed'\n   *   }\n   * }}>\n   * ```\n   */\n  theme?: Theme;\n  /**\n   * The map style to use, either `'default'` or `'satellite'`. The default map\n   * style is configurable with {@link AddressMinimapProps#defaultMapStyle}.\n   */\n  mapStyleMode?: MapStyleMode;\n  /**\n   * The map style to use for the default map style. Defaults to `['mapbox', 'streets-v11']`.\n   */\n  defaultMapStyle?: [string, string];\n  /**\n   * Custom footer text appearing below the map, when marker adjustment is enabled.\n   * If `true` or left undefined, the default footer text will be used.\n   * If `false`, the footer will not be shown.\n   */\n  footer?: boolean | string;\n  /**\n   * Custom adjust button text appearing on the map.\n   * If not provided, the default text will be used.\n   */\n  adjustBtnText?: string;\n  /**\n   * Custom cancel button text appearing on the map, when marker adjustment is enabled.\n   * If not provided, the default text will be used.\n   */\n  cancelBtnText?: string;\n  /**\n   * Custom save button text appearing on the map, when marker adjustment is enabled.\n   * If not provided, the default text will be used.\n   */\n  saveBtnText?: string;\n}\n\n/**\n * `AddressMinimap` is a React component that displays a marker for confirmation purposes.\n *\n * Optionally, this marker is editable. When editable, the marker can be moved\n * around the map and the updated location is sent back to the Mapbox Contribute\n * workflow.\n *\n * The goal of `AddressMinimap` is to reduce delivery or geolocation error in shipping and\n * local dispatching contexts.\n *\n * `AddressMinimap` expands to fill its container, and is hidden unless\n * {@link AddressMinimapProps#feature} and {@link AddressMinimapProps#show} are truthy.\n *\n * Internally, this wraps the [`<mapbox-address-minimap>`](https://docs.mapbox.com/mapbox-search-js/api/web/minimap/#mapboxaddressminimap) element.\n *\n * @class AddressMinimap\n * @param {AddressMinimapProps} props\n * @example\n * ```typescript\n * export function Component() {\n *   return (\n *     <AddressMinimap accessToken={'YOUR_MAPBOX_ACCESS_TOKEN'}>\n *     </AddressMinimap>\n *   );\n * }\n * ```\n */\nexport function AddressMinimap(props: AddressMinimapProps): React.ReactElement {\n  const {\n    canAdjustMarker = false,\n    keepMarkerCentered = false,\n    markerAnchor = 'bottom',\n    onSaveMarkerLocation,\n\n    show = false,\n    accessToken,\n    feature = null,\n\n    adjustBtnText,\n    saveBtnText,\n    cancelBtnText,\n\n    satelliteToggle = false,\n    theme,\n    mapStyleMode = 'default',\n    defaultMapStyle = ['mapbox', 'streets-v11'],\n    footer\n  } = props;\n  const ref = useRef<MapboxAddressMinimap>();\n\n  // Update show.\n  useEffect(() => {\n    if (!ref.current) return;\n    if (show) {\n      ref.current.show();\n    } else {\n      ref.current.hide();\n    }\n  }, [ref.current, show]);\n\n  // Update theme.\n  useEffect(() => {\n    if (ref.current) ref.current.theme = theme;\n  }, [ref.current, theme]);\n\n  // Update feature.\n  useEffect(() => {\n    if (ref.current) ref.current.feature = show ? feature : null;\n  }, [ref.current, feature, show]);\n\n  // Update mapStyleMode.\n  useEffect(() => {\n    if (ref.current) ref.current.mapStyleMode = mapStyleMode;\n  }, [ref.current, mapStyleMode]);\n\n  // Update adjustBtnText.\n  useEffect(() => {\n    if (adjustBtnText === undefined) return;\n    if (ref.current) ref.current.adjustBtnText = adjustBtnText;\n  }, [ref.current, adjustBtnText]);\n\n  // Update saveBtnText.\n  useEffect(() => {\n    if (saveBtnText === undefined) return;\n    if (ref.current) ref.current.saveBtnText = saveBtnText;\n  }, [ref.current, saveBtnText]);\n\n  // Update cancelBtnText.\n  useEffect(() => {\n    if (cancelBtnText === undefined) return;\n    if (ref.current) ref.current.cancelBtnText = cancelBtnText;\n  }, [ref.current, cancelBtnText]);\n\n  // Update defaultMapStyle.\n  useEffect(() => {\n    if (ref.current) ref.current.defaultMapStyle = defaultMapStyle;\n  }, [ref.current, defaultMapStyle]);\n\n  // Update footer.\n  useEffect(() => {\n    if (footer === undefined) return;\n    if (ref.current) ref.current.footer = footer;\n  }, [ref.current, footer]);\n\n  // Update accessToken.\n  useEffect(() => {\n    if (ref.current) ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n\n  // Update onSaveMarkerLocation callback\n  useEffect(() => {\n    if (ref.current) ref.current.onSaveMarkerLocation = onSaveMarkerLocation;\n  }, [ref.current, onSaveMarkerLocation]);\n\n  return (\n    <mapbox-address-minimap\n      ref={ref}\n      can-adjust-marker={canAdjustMarker}\n      keep-marker-centered={keepMarkerCentered}\n      marker-anchor={markerAnchor}\n      satellite-toggle={satelliteToggle}\n    />\n  );\n}\n", "import { useEffect, useRef } from 'react';\nimport { Evented } from '@mapbox/search-js-core';\n\n/**\n * A React hook to register an event listener on a Search JS Core Evented object.\n *\n * {@link Evented} is a base class that is inherited by {@link SearchSession}.\n */\nexport function useEvented<T, K extends keyof T>(\n  evented: Evented<T> | null,\n  eventName: K,\n  cb: (object: T[K]) => unknown\n): void {\n  const cbRef = useRef(cb);\n  useEffect(() => {\n    cbRef.current = cb;\n  });\n\n  useEffect(() => {\n    if (!evented) return;\n\n    const fn = (object?: T[K]) => cbRef.current(object);\n    evented.addEventListener(eventName, fn);\n\n    return () => {\n      evented.removeEventListener(eventName, fn);\n    };\n  }, [evented, eventName, cbRef]);\n}\n", "import { useEffect, useMemo } from 'react';\nimport {\n  AddressAutofillOptions,\n  AddressAutofillCore\n} from '@mapbox/search-js-core';\n\nconst DEFAULTS = AddressAutofillCore.defaults;\n\n/**\n * A React hook that returns a {@link AddressAutofillCore} instance.\n *\n * @param {AddressAutofillOptions} options\n * @param {string} options.accessToken Your Mapbox access token.\n * @see {@link AddressAutofillCore}\n * @example\n * ```typescript\n * import { useAddressAutofillCore } from '../src';\n * const autofill = useAddressAutofillCore({ accessToken: 'YOUR_MAPBOX_ACCESS_TOKEN' });\n * const response = await autofill.suggest('1600 pennsylvania ave nw', {\n *   sessionToken: 'test-123'\n * });\n * console.log(response);\n * // { suggestions: [...], attribution: '...' };\n * ```\n * @see {@link AddressAutofillCore}\n */\nexport function useAddressAutofillCore(\n  options: Partial<{ accessToken: string } & AddressAutofillOptions>\n): AddressAutofillCore {\n  const autofill = useMemo(() => {\n    return new AddressAutofillCore();\n  }, []);\n\n  useEffect(() => {\n    const { accessToken, ...restOptions } = options;\n    autofill.accessToken = accessToken;\n    autofill.defaults = {\n      ...DEFAULTS,\n      ...restOptions\n    };\n  }, [options]);\n\n  return autofill;\n}\n", "import { useEffect, useMemo } from 'react';\nimport { SearchBoxCore, SearchBoxOptions } from '@mapbox/search-js-core';\n\nconst DEFAULTS = SearchBoxCore.defaults;\n\n/**\n * A React hook that returns a {@link SearchBoxCore} instance.\n *\n * @param {SearchBoxOptions} options\n * @param {string} options.accessToken Your Mapbox access token.\n * @see {@link SearchBoxCore}\n * @example\n * ```typescript\n * import { useSearchBoxCore } from '@mapbox/search-js-react';\n * const searchBoxCore = useSearchBoxCore({ accessToken: 'YOUR_MAPBOX_ACCESS_TOKEN' });\n * const response = await searchBoxCore.suggest('1600 pennsylvania ave nw', {\n *   sessionToken: 'test-123'\n * });\n * console.log(response);\n * // { suggestions: [...], attribution: '...', url: '...' };\n * ```\n */\nexport function useSearchBoxCore(\n  options: Partial<{ accessToken: string } & SearchBoxOptions>\n): SearchBoxCore {\n  const search = useMemo(() => {\n    return new SearchBoxCore();\n  }, []);\n\n  useEffect(() => {\n    const { accessToken, ...restOptions } = options;\n    search.accessToken = accessToken;\n    search.defaults = {\n      ...DEFAULTS,\n      ...restOptions\n    };\n  }, [options]);\n\n  return search;\n}\n", "import { useEffect, useMemo } from 'react';\nimport { GeocodingCore, GeocodingOptions } from '@mapbox/search-js-core';\n\n/**\n * A React hook that returns a {@link GeocodingCore} instance.\n *\n * @param {GeocodingOptions} options\n * @param {string} options.accessToken Your Mapbox access token.\n * @see {@link GeocodingCore}\n * @example\n * ```typescript\n * import { useGeocodingCore } from '@mapbox/search-js-react';\n * const geocodingCore = useGeocodingCore({ accessToken: 'YOUR_MAPBOX_ACCESS_TOKEN' });\n * const response = await geocodingCore.forward('1600 pennsylvania ave nw', {\n *   limit: 1\n * });\n * console.log(response);\n * // { type: 'FeatureCollection', features: [...], attribution: '...', url: '...' };\n * ```\n */\nexport function useGeocodingCore(\n  options: Partial<{ accessToken: string } & GeocodingOptions>\n): GeocodingCore {\n  const search = useMemo(() => {\n    return new GeocodingCore();\n  }, []);\n\n  useEffect(() => {\n    const { accessToken, ...restOptions } = options;\n    search.accessToken = accessToken;\n    search.defaults = {\n      ...restOptions\n    };\n  }, [options]);\n\n  return search;\n}\n", "import {\n  AddressAutofillOptions,\n  AddressAutofillRetrieveResponse,\n  AddressAutofillSuggestion,\n  AddressAutofillSuggestionResponse,\n  AddressAutofillCore,\n  SearchBoxCore,\n  SearchBoxOptions,\n  SearchBoxRetrieveResponse,\n  SearchBoxSuggestion,\n  SearchBoxSuggestionResponse,\n  GeocodingOptions,\n  GeocodingFeature,\n  GeocodingResponse,\n  GeocodingCore,\n  SearchSession\n} from '@mapbox/search-js-core';\nimport { useMemo } from 'react';\n\nexport type SearchSessionType = SearchSession<\n  SearchBoxOptions,\n  SearchBoxSuggestion,\n  SearchBoxSuggestionResponse,\n  SearchBoxRetrieveResponse\n>;\n\nexport type AddressAutofillSearchSessionType = SearchSession<\n  AddressAutofillOptions,\n  AddressAutofillSuggestion,\n  AddressAutofillSuggestionResponse,\n  AddressAutofillRetrieveResponse\n>;\n\nexport type GeocodingSearchSessionType = SearchSession<\n  GeocodingOptions,\n  GeocodingFeature,\n  GeocodingResponse,\n  GeocodingFeature\n>;\n\nfunction useSearchSession(search: SearchBoxCore): SearchSessionType;\nfunction useSearchSession(geocoding: GeocodingCore): GeocodingSearchSessionType;\nfunction useSearchSession(\n  autofill: AddressAutofillCore\n): AddressAutofillSearchSessionType;\n\n/**\n * A React hook that returns a {@link SearchSession} instance.\n *\n * @param {SearchBoxCore | AddressAutofillCore} search\n * @returns {SearchSession}\n * @see {@link SearchSession}\n */\nfunction useSearchSession(\n  search: SearchBoxCore | AddressAutofillCore | GeocodingCore\n):\n  | SearchSessionType\n  | AddressAutofillSearchSessionType\n  | GeocodingSearchSessionType {\n  const searchSession = useMemo(() => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new SearchSession(search as any);\n  }, [search]);\n\n  if (search instanceof SearchBoxCore) {\n    return searchSession as SearchSessionType;\n  } else if (search instanceof GeocodingCore) {\n    return searchSession as GeocodingSearchSessionType;\n  } else {\n    return searchSession as AddressAutofillSearchSessionType;\n  }\n}\n\nexport { useSearchSession };\n", "import { useMemo, useRef } from 'react';\n\nimport {\n  AddressConfirmOptions,\n  AddressConfirmShowResult,\n  confirmAddress\n} from '@mapbox/search-js-web';\n\ninterface UseConfirmAddressObject {\n  formRef: React.RefObject<HTMLFormElement>;\n  showConfirm: (\n    options?: Partial<AddressConfirmOptions>\n  ) => Promise<AddressConfirmShowResult>;\n}\n\n/**\n * A React hook that returns a form ref and a function to show the address confirmation modal\n *\n * @param {AddressConfirmOptions} optionsArg\n * @see {@link confirmAddress}\n * @example\n * ```typescript\n * import { useConfirmAddress } from '@mapbox/search-js-react';\n *\n * export function Autofill(): React.ReactElement {\n *   const { formRef, showConfirm } = useConfirmAddress({\n *     footer: 'My custom footer'\n *   });\n *\n *   const handleSubmit = React.useCallback(async () => {\n *     const result = await showConfirm();\n *      console.log(result);\n *   }, [showConfirm]);\n *\n *   return (\n *     <div>\n *       <form\n *         ref={formRef}\n *         style={{ display: 'flex', flexDirection: 'column', marginTop: 30 }}\n *       >\n *         <AddressAutofill\n *           ...\n *         >\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useConfirmAddress(\n  optionsArg: AddressConfirmOptions = {}\n): UseConfirmAddressObject {\n  const formRef = useRef<HTMLFormElement>(null);\n  return useMemo(() => {\n    return {\n      formRef,\n      showConfirm: () => confirmAddress(formRef.current, optionsArg)\n    };\n  }, [formRef, optionsArg]);\n}\n"],
  "mappings": "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",
  "names": []
}
